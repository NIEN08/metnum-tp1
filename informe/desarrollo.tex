\section{Desarrollo}

\subsection{Sobre la implementación}

En principio, y con la intención de entender el problema en profundidad, planteamos un ejemplo que resolvimos manualmente. A partir de este ejemplo notamos un patrón en el comportamiento del sistema. Por lo tanto recrearemos a continuación dicho ejemplo, para dar una noción clara de nuestra evolución en la comprensión de este problema particular. Asumamos que recibimos un archivo de entrada con los siguientes parámetros:\\

3 \ \ \ \   3  \ \ \ \ 1 \ \ \ \ 1\\
2.5  \ \ \ \ 2.5 \ \ \ \ 1  \ \ \ \ 500

entonces el problema modelado es de la pinta$^6$:\footnotetext[6]{Aclaramos que la circunferencia negra representa una sanguijuela mutante y el cuadrado celeste, al parabrisas.}

\begin{figure}[h]
    \centering
    \includegraphics[width=0.3\textwidth]{ejP01}
    \caption{Imagen ilustrativa del parabrisas}
\end{figure}

Luego lo representaremos como muestra el gráfico a continuación, donde cada intersección de las lineas representa una variable del modelo, de la cual debemos averiguar su temperatura.

\begin{figure}[h]
    \centering
    \includegraphics[width=0.3\textwidth]{ejP02}
    \caption{Representación visual del modelo discretizado}
\end{figure}

Notar que, si bien C, D y H pertenecen al radio de una sanguijuela, al formar parte del borde están condicionados por el sistema de refrigeración, por lo cual su temperatura es $-100$ en lugar de $500$. Planteando la ecuación de temperatura para cada variable y despejando, obtenemos el siguiente sistema de ecuaciones $Ax=B$:

\begin{equation}
 a\ =\ -100
\end{equation}
\begin{equation}
 b\ =\ -100
\end{equation}
\begin{equation}
 c\ =\ -100
\end{equation}
\begin{equation}
 d\ =\ -100
\end{equation}
\begin{equation}
 e\ =\ -100
\end{equation}
\begin{equation}
 f - \frac{b}{4} - \frac{e}{4} - \frac{g}{4} - \frac{j}{4}\ =\ 0
\end{equation}
\begin{equation}
 g\ =\ 500
\end{equation}
\begin{equation}
 h\ =\ -100
\end{equation}
\begin{equation}
 i\ =\ -100
\end{equation}
\begin{equation}
 j- \frac{f}{4} - \frac{i}{4} - \frac{k}{4} - \frac{n}{4}\ =\ 0
\end{equation}
\begin{equation}
 k- \frac{g}{4} - \frac{j}{4} - \frac{l}{4} - \frac{o}{4}\ =\ 0
\end{equation}
\begin{equation}
 l\ =\ -100
\end{equation}
\begin{equation}
 m\ =\ -100
\end{equation}
\begin{equation}
 n\ =\ -100
\end{equation}
\begin{equation}
 o\ =\ -100
\end{equation}
\begin{equation}
 p\ =\ -100
\end{equation}

del cual la matriz asociada $A$ es la siguiente:
 
%Matriz del sistema
\begin{center}
   \begin{tabular}{| c | c | c | c | c | c | c | c | c |c | c |c | c |c | c | c | c | c | c | c | c |c | c |c | c |c | c |c | c |}
     \hline
       & a  & b & c & d & e & f & g & h & i & j & k & l & m & n & o & p  \\ \hline
   (3) & 1  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
   (4) & 0  & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
   (5) & 0  & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
   (6) & 0  & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
   (7) & 0  & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
   (8) & 0  & $-\frac{1}{4} $ & 0 & 0 & $-\frac{1}{4} $ & 1 & $-\frac{1}{4} $ & 0 & 0 & $-\frac{1}{4} $& 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
   (9) & 0  & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
   (10) & 0  & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
   (11) & 0  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
   (12) & 0  & 0 & 0 & 0 & 0 & $-\frac{1}{4} $ & 0 & 0 & $-\frac{1}{4} $ & 1 & $-\frac{1}{4} $ & 0 & 0 & $-\frac{1}{4} $ & 0 & 0 \\ \hline
   (13) & 0  & 0 & 0 & 0 & 0 & 0 & $-\frac{1}{4} $ & 0 & 0 & $-\frac{1}{4} $ & 1 & $-\frac{1}{4} $ & 0 & 0 & $-\frac{1}{4} $ & 0 \\ \hline
   (14) & 0  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\ \hline
   (15) & 0  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\ \hline
   (16) & 0  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\ \hline
   (17) & 0  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\ \hline
   (18) & 0  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\ \hline
   \end{tabular}
\end{center}

siendo la ecuación (3) la resultante de despejar la ecuación de temperatura para la variable $a$, (4) para la variable $b$ y así sucesivamente.

Ordenándolo de esta manera, la matriz asociada $A$ es una matriz banda de ancho y altura n, donde n es la cantidad de columnas  de la matriz de temperaturas. Esto lo deducimos observando la figura 2 y la matriz A, ya que notamos que para averiguar el valor de la variable $v_{i}$ son necesarios$^7$ los valores de las variables $v_{i-n}$, $v_{i-1}$, $v_{i+1}$, $v_{i+n}$, donde n hace referencia a la cantidad de columnas. \footnotetext[7]{Siempre y cuando $v_{i}$ no pertenezca a un borde o este cubierta por una sanguijuela.}

Notar que en las ecuaciones, o lo que es lo mismo, matriz asociada al sistema no se hicieron remplazos previos. Con esto nos referimos a no reemplazar en las ecuaciones de calor automáticamente los valores conocidos, como los del borde o los afectados por sanguijuelas. Un ejemplo de esto se daría al usar las ecuaciones (4), (7) y (9) para reemplazar los valores en la ecuación (8). Tomamos esta decisión porque consideramos que esos reemplazos son parte de la resolución total del sistema, por lo que deberían verse reflejados en la medición de tiempos. Sin embargo, si hiciéramos los reemplazos en la generación de la matriz asociada al sistema, no podríamos medirlos con confiabilidad pues tendríamos la lectura de datos como outlier. También debemos tener en cuenta el caso de que, por algún motivo, se deba cambiar el valor de la temperatura de los bordes. Dise\~nado de este modo, tenemos mayor escalabilidad$^8$. \footnotetext[8]{Buscando siempre seguir las buenas practicas de programación.}

Dejaremos el ejemplo hasta aquí, pues la resolución del sistema no aporta información útil. Sin embargo, una vez que hallamos esta estructura procedimos a realizar la carga de datos de modo que la matriz asociada a nuestro sistema fuese una matriz banda-n. Ahora explicaremos el desarrollo del código.
%\footnotetext[8]{Por dato del enunciado, en ese momento sabiamos que debimos obtener una matriz banda a partir del sistema, si bien no sabiamos como organizar los datos para obtenerla.}

El lenguaje empleado para la implementación es C++. Si bien la elección del lenguaje podría considerarse arbitraria, se debió principalmente a la gran cantidad de herramientas y librerías provistas por este lenguaje, a diferencia de la otra opción dada por la cátedra. 

Luego de implementada Eliminación Gaussiana y Factorizaci\'on LU, procedimos a crear la interfaz del problema en si, es decir la entrada y salida de datos, la generación del sistema, etc. Establecimos como criterio usar el promedio de las temperaturas, de todos los puntos que estén en el interior en la circunferencia de radio h con centro en el punto crítico, para la estimación de la temperatura del mismo. En particular, si el punto critico es un punto de la discretizaci\'on, entonces es el único punto en el interior de la circunferencia.

%%%%%%%%%% TODO: Terminar. Hay que escribir exactamente cómo se hacen los cálculos y justificar.

Para finalizar la implementación, programamos el Algoritmo Simple para calcular cual sanguijuela eliminar, y algoritmo mejorado con la fórmula de Sherman-Morrison. 

La fórmula de Sherman-Morrison nos permite conseguir un sistema equivalente al de $(A+B)^{-1}x=b$ si podemos encontrar dos vectores $u$ y $v$ tales que $uv^t=B$.

  Supongamos que queremos resolver el sistema $  (A + uv^{t})x = b $ con solucion unica. \\\ 
   
 $\iff x = (A + uv^{t})^{-1} b$   \\\
 $\iff_{SM} $ $ x = A^{-1}b -  \dfrac{A^{-1}u v^{t}A^{-1}b}{1+v^{t}A^{-1}u}$ \\\
$\iff $ $ x = A^{-1}b -  \dfrac{v^{t}A^{-1}b}{1+v^{t}A^{-1}u} A^{-1}u $\\\
Pero sabemos que: \\\
$A^{-1}b = y \iff Ay = b$ \\\
$A^{-1}u = z \iff Az = u$ \\\

Suponiendo que ya resolvimos el sistema A antes de la modificacion, tenemos su descomposicion, $ LU=A $. Por lo que basta resolver: \\\
$Ly_{2}= b $ y $ Lz_{2} = u$ \\\
Luego, $ Uy=y_{2} $ y $ Uz=z_{2}$ \\\
Una vez calculados $ y $ y $ z $ estamos en condiciones de resolver la expresion. Notemos que $ \dfrac{v^{t}A^{-1}b}{1+v^{t}A^{-1}u} $ es un escalar. \\\

Finalmente $ x = y - \dfrac{v^{t}y}{1+v^{t}z} z$ \\\

En cuanto a $ uv^{t} $ recordemos que vamos a usar sherman-morrison para sistemas que cambian una ecuacion del sistema. Cuando una posicion discretizada i,j se vea afectada por una sanguijuela singular (solo afecte una posicion del sistema discreto) y esa posicion no caiga en el radio discretizado de ninguna otra sanguijuela vamos a volver a pedir que la temperatura de esa posicion discretizada se rija por la ecuaci\'on de Laplace. Por lo que la modificaci\'on ser\'a:  \\\

$ A + Eq $ donde $Eq = uv^{t} $ la matriz donde todas las filas ser\'an ceros excepto la fila de la ecuacion correspondiente a la temperatura $(i, j)$. Esta fila tendr\'a el valor $-1/4$ para las columnas correspondientes a las posiciones $(i,j-1),(i-1,j), (i,j+1), (i+1,j) $.\\\

Constru\'imos los vectores $u, v$ de la siguiente manera. Si la matriz del sistema de ecuaci\'ones $A$ tiene dimensi\'on $(n*m)*(n*m)$, donde $(n*m)$ es la dimensi\'on de la matriz de temperaturas discretizada, entonces la fila correspondiente a la ecuaci\'on $(i,j)$ en la matriz del sistema sera la fila $f = i*n + j$. De forma tal que $u_{f} = 1.0$ y $u_{k} = 0.0$ $ \forall k \neq f$.\\\

Adem\'as $v_{c_{1}} = v_{c_{2}} = v_{c_{3}} = v_{c_{4}} -1/4$ y  $v_{k} = 0.0$ $ \forall k \neq c_{1},c_{2},c_{3},c_{4}$. Donde: \\
\begin{itemize}
\item $c_{1} = i*n + (j-1)$
\item $c_{2} = (i-1)*n + j$
\item $c_{3} = i*n + (j+1)$
\item $c_{4} = (i+1)*n + j$
\end{itemize}


En cuanto a $ uv^{t} $ recordemos que vamos a usar Sherman-Morrison para sistemas que cambian una sola fila i, por lo que nos basta con
conseguir que $ uv^{t} $ sea una matriz que modifique apropiadamente dicha fila. Por lo tanto tomamos a $u$ como el i-ésimo vector de la base canónica,
y a $v$ como la modificación que necesitamos para transformar la fila i.

\subsubsection{Pseudocódigo}


\noindent\fbox{
\begin{minipage}{1\textwidth}
\begin{algorithmic}[1]
\State{backwardsustitution(matriz m, vector b)}
\State{sea res el vector con longitud igual a la cantidad columnas de m}
\State{sea n el mínimo entre la cantidad de columnas y de filas de m}
\For {$i \gets 0$; $ i < n$; $i--$}
    \If{si $i==0$}
        \State{asigno al coeficiente i el valor 1 en res$_i$}
    \Else
        \State{calculo el valor del coeficiente i, y lo guardo en res$_i$}
    \EndIf
\EndFor
\State{devuelvo res}
\end{algorithmic}
\end{minipage}
}
\\ \\
El pseudocodigo de fordwardsustitution es analogo por lo que no se adjunta.
\\ \\ 
\noindent\fbox{
\begin{minipage}{1\textwidth}
\begin{algorithmic}[1]
\State{eliminacion\_gaussiana(matriz m, vector b)}
\State{sea res el vector con longitud igual a la cantidad columnas de m}
\State{sea d el mínimo entre la cantidad de columnas y de filas de m}
\For {$i \gets 0$; $ i < d$; $i--$}
    \While{haya alguna fila $f_j$ inferior a la fila i, con el coeficiente $f_{j_i} \neq 0$ }
        \State{resto $f_i$ a $f_j$ con el coeficiente apropiado para que $f_{j_i} == 0$}
        \State{guardo el resultado en m, reemplazando a la fila $f_j$}
    \EndWhile
\EndFor
\State{devuelvo backward\_substitution(m,b)}
\end{algorithmic}
\end{minipage}
}\\\\

\noindent\fbox{
\begin{minipage}{1\textwidth}
\begin{algorithmic}[1]
\State{LU\_factorization(matriz A)}
\State{sean L, U dos matrices de las mismas dimenciones que A, con 1's en la diagonal}
\State{sea d el mínimo entre la cantidad de columnas y de filas de m}
\For {$i \gets 0$; $ i < d$; $i--$}
    \While{haya alguna fila $f_j$ inferior a la fila i, con el coeficiente $f_{j_i} \neq 0$ }
        \State{resto $f_i$ a $f_j$ con el coeficiente apropiado para que $f_{j_i} == 0$}
        \State{guardo el resultado en U reemplazando a la fila $f_j$}
        \State{guardo el coeficiente en L, en la fila j columna i}
    \EndWhile
\EndFor
\State{devuelvo L y U}
\end{algorithmic}
\end{minipage}
}
\vspace{0.5cm}

\noindent\fbox{
\begin{minipage}{1\textwidth}
\begin{algorithm}[H]
 \KwData{$L,U \in  \mathbb{R}^{(n \times m)^{2}}$ factorizaci\'on $LU$ del sistema. \\
  $l$ sanguijuela a procesar.}
 \KwResult{$b \in  \mathbb{R}^{n \cdot m}$ temperaturas de las coordenadas del parabrisas. \\ }
 \vspace{0.5cm}	
 
	$P(unique):$ "la posici\'on y radio discretizado de la sanguijuela afecta una sola fila de la matriz
	del sistema."
 	\vspace{0.5cm}
	
	\eIf{$\neg P(unique)$} {
		$b = LU\_resolution(L,U)$
	}{
		$u,v = generate\_sherman\_morrison\_uv(l)$\\
		$b = sherman\_morrison\_resolution(L,U,u,v)$
	}
 	\vspace{0.5cm}
 	
	
	\Return {$b$}
\caption{singular\_leech\_resolution\label{intro_alg_interpolation}}  
\end{algorithm} 
\end{minipage}
} 
\vspace{0.5cm}

El algoritmo $build\_system$


\subsection{Sobre la experimentación}

Para medir los tiempos de resolución, utilizamos la función gettimeof day, que permite medir con
facilidad el lapso de tiempo entre dos momentos de la ejecución del programa. Decidimos medir
únicamente los tiempos que estuvieran estrictamente relacionados a la resolución del sistema,
dejando afuera, por ejemplo, el tiempo empleado para escribir las soluciones en archivos de salida. La
idea de fondo que nos llevó a medir de esta manera fue la de intentar que las magnitudes de los tiempos
empleados por los métodos de triangulación de Gauss y LU no se vieran afectadas por tiempos mucho
mayores que distorsionaran la distancia relativa entre ellas.

Una vez finalizada la etapa de implementación y testeo de los algoritmos, procedimos a realizar una
serie de experimentos que nos permitieran evaluar el comportamiento de los mismos. Además de
analizar como se modifican los resultados a medida que se modifica el parámetro de discretización
h, definimos algoritmos para comparar el desempeño, en términos de la estimación de temperaturas.
Por comodidad, a la hora de diseñar los experimentos, definimos todos los parabrisas con forma cuadrada.

Siguiendo la consigna del TP, planteamos tres casos diferentes para analizar como varia la temperatura 
en el punto critico al variar la discretización. Estos casos fueron generados de manera pseudo aleatoria. Es decir, si bien las posiciones de las sanguijuelas se establecieron usando una distribución uniforme y la temperatura usando una distribución normal~\cite{proba}, restringimos los rangos de ambos parámetros para lograr la instancia deseada.
