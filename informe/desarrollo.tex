\section{Desarrollo}

\subsection{Sobre la implementación}
En principio, y con la intención de entender el problema en profundidad, planteamos un ejemplo que resolvimos manualmente. A partir de este ejemplo
notamos un patrón en el comportamiento del sistema. Por lo tanto recrearemos a continuación dicho ejemplo, para dar una noción clara de nuestra 
evolución en la comprensión de este problema particular.

Asumamos que recibimos un archivo de entrada con los siguientes parámetros:\\

3 \ \ \ \   3  \ \ \ \ 1 \ \ \ \ 1\\
0.5  \ \ \ \ 2.5 \ \ \ \ 1  \ \ \ \ 500

entonces el problema modelado es de la pinta$^6$:\footnotetext[6]{Aclaramos
que la circunferencia negra representa una sanguijuela mutante y el cuadrado celeste, al parabrisas.}

\begin{figure}[]
    \includegraphics[width=0.3\textwidth]{ejP01}
    \caption{Imagen ilustrativa del parabrisas}
\end{figure}

Luego lo representaremos como muestra el gráfico a continuación, donde cada intersección de las lineas representa una variable del modelo, de la cual
debemos averiguar su temperatura.

\begin{figure}[]
    \includegraphics[width=0.3\textwidth]{ejP02}
    \caption{Representación visual del modelo discretizado}
\end{figure}

Notar que, si bien C, D y H pertenecen al radio de una sanguijuela, al formar parte del borde están condicionados por el sistema de refrigeración,
por lo cual su temperatura es $-100$ en lugar de $500$.

Planteando la ecuación de temperatura para cada variable y despejando, obtenemos el siguiente sistema de ecuaciones $Ax=B$:
\begin{equation}
 a\ =\ -100
\end{equation}
\begin{equation}
 b\ =\ -100
\end{equation}
\begin{equation}
 c\ =\ -100
\end{equation}
\begin{equation}
 d\ =\ -100
\end{equation}
\begin{equation}
 e\ =\ -100
\end{equation}
\begin{equation}
 f - \frac{b}{4} - \frac{e}{4} - \frac{g}{4} - \frac{j}{4}\ =\ 0
\end{equation}
\begin{equation}
 g\ =\ 500
\end{equation}
\begin{equation}
 h\ =\ -100
\end{equation}
\begin{equation}
 i\ =\ -100
\end{equation}
\begin{equation}
 j- \frac{f}{4} - \frac{i}{4} - \frac{k}{4} - \frac{n}{4}\ =\ 0
\end{equation}
\begin{equation}
 k- \frac{g}{4} - \frac{j}{4} - \frac{l}{4} - \frac{o}{4}\ =\ 0
\end{equation}
\begin{equation}
 l\ =\ -100
\end{equation}
\begin{equation}
 m\ =\ -100
\end{equation}
\begin{equation}
 n\ =\ -100
\end{equation}
\begin{equation}
 o\ =\ -100
\end{equation}
\begin{equation}
 p\ =\ -100
\end{equation}

 del cual la matriz asociada $A$ es la siguiente:
 
%Matriz del sistema
\begin{center}
   \begin{tabular}{| c | c | c | c | c | c | c | c | c |c | c |c | c |c | c | c | c | c | c | c | c |c | c |c | c |c | c |c | c |}
     \hline
       & a  & b & c & d & e & f & g & h & i & j & k & l & m & n & o & p  \\ \hline
   (3) & 1  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
   (4) & 0  & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
   (5) & 0  & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
   (6) & 0  & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
   (7) & 0  & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
   (8) & 0  & $-\frac{1}{4} $ & 0 & 0 & $-\frac{1}{4} $ & 1 & $-\frac{1}{4} $ & 0 & 0 & $-\frac{1}{4} $& 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
   (9) & 0  & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
   (10) & 0  & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
   (11) & 0  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
   (12) & 0  & 0 & 0 & 0 & 0 & $-\frac{1}{4} $ & 0 & 0 & $-\frac{1}{4} $ & 1 & $-\frac{1}{4} $ & 0 & 0 & $-\frac{1}{4} $ & 0 & 0 \\ \hline
   (13) & 0  & 0 & 0 & 0 & 0 & 0 & $-\frac{1}{4} $ & 0 & 0 & $-\frac{1}{4} $ & 1 & $-\frac{1}{4} $ & 0 & 0 & $-\frac{1}{4} $ & 0 \\ \hline
   (14) & 0  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\ \hline
   (15) & 0  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\ \hline
   (16) & 0  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\ \hline
   (17) & 0  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\ \hline
   (18) & 0  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\ \hline
   \end{tabular}
\end{center}

siendo la ecuación (3) la resultante de despejar la ecuación de temperatura para la variable $a$, (4) para la variable $b$ y así sucesivamente.
Ordenándolo de esta manera, la matriz asociada $A$ es una matriz banda de ancho y altura n, donde n es la cantidad de columnas 
de la matriz de temperaturas. Esto lo deducimos observando la figura 2 y la matriz A,
ya que notamos que para averiguar el valor de la variable $v_{i}$ son necesarios$^7$ los valores de las variables $v_{i-n}$, $v_{i-1}$, 
$v_{i+1}$, $v_{i+n}$, donde n hace referencia a la cantidad de columnas.
\footnotetext[7]{Siempre y cuando $v_{i}$ no pertenezca a un borde o este cubierta por una sanguijuela.}
Notar que en las ecuaciones, o lo que es lo mismo, matriz asociada al sistema no se hicieron remplazos previos. Con esto nos referimos a no reemplazar
 en las ecuaciones de calor automáticamente los valores conocidos, como los del borde o los afectados por sanguijuelas. Un ejemplo de esto se daría 
 al usar las ecuaciones (4), (7) y (9) para reemplazar los valores en la ecuación (8). Tomamos esta decisión porque consideramos que esos reemplazos son parte
 de la resolución total del sistema, por lo que deberían verse reflejados en la medición de tiempos. Sin embargo, si hiciéramos los reemplazos 
 en la generación de la matriz asociada al sistema, no podríamos medirlos con confiabilidad pues tendríamos la lectura de datos como outlier.

Dejaremos el ejemplo hasta aquí, pues la resolución del sistema no aporta información útil. Sin embargo, una vez que hallamos esta estructura 
procedimos a realizar la carga de datos de modo que la matriz asociada a nuestro sistema fuese una matriz banda-n. Ahora explicaremos el desarrollo del código.
%\footnotetext[8]{Por dato del enunciado, en ese momento sabiamos que debiamos obtener una matriz banda a partir del sistema, si bien no sabiamos como
%organizar los datos para obtenerla.}

El lenguaje empleado para la implementación es C++. Si bien la elección del lenguaje podría considerarse arbitraria, se debió principalmente a la 
cantidad de herramientas y librerías provistas por este lenguaje. 

En primer instancia, creamos una clase llamada BDouble para representar decimales de
precisión doble para guardar el error estimado acumulado. Esto nos sirvió a la hora de debbugear el código.
Luego creamos la clase Matrix, que representa a las matrices como un vector de vectores de BDouble. 
Además guarda la dimensión de la matriz, el ancho y alto de la banda. Para mejorar la complejidad espacial, solo guarda por fila aquellos
coeficientes pertenecientes a la banda, o sea, aquellos que no valen necesariamente cero. Esta clase provee las funciones básicas para matriz, como 
consultar su dimensión o sumar múltiplos de filas entre si, pero además, contiene las funciones gaussian\_elimination, LU\_factorization, backward\_substitution y 
forward\_substitution. 

Si bien nuestra primera idea fue crear una clase aparte para estos métodos, y por claridad abstraernos en esta de la 
representación interna de la matriz, al hacerlo nos topamos con un problema en los header's del código. Al no poder descubrir el motivo
de dicho problema, recurrimos a la cátedra en busca de consejo. Aun así, no encontramos el motivo. Es por esto que incluimos la implementación de
estos algoritmos en la clase Matrix. 

Luego procedimos a crear la interfaz del problema en si, es decir la entrada y salida de datos, la generación
del sistema, etc. Establecimos como criterio usar el promedio de las temperaturas, de todos los puntos que estén
incluidos en la circunferencia de radio h con centro en el punto crítico,
para la estimación de la temperatura del mismo. 

Para finalizar la implementación, programamos el Algoritmo Simple para calcular cual sanguijuela eliminar,
y algoritmo mejorado con la fórmula de Sherman-Morrison. 

La fórmula de Sherman-Morrison nos permite conseguir un sistema equivalente al de $(A+B)^{-1}x=b$ si podemos encontrar dos vectores $u$ y $v$
tales que $uv^t=B$.

\input{s-m.tex}

\subsubsection{Pseudocódigo}

\subsection{Sobre la experimentación}

Para medir los tiempos de resolución, utilizamos la función gettimeof day, que permite medir con
facilidad el lapso de tiempo entre dos momentos de la ejecución del programa. Decidimos medir
únicamente los tiempos que estuvieran estrictamente relacionados a la resolución del sistema,
dejando afuera, por ejemplo, el tiempo empleado para escribir las soluciones en archivos de salida. La
idea de fondo que nos llevó a medir de esta manera fue la de intentar que las magnitudes de los tiempos
empleados por los métodos de triangulación de Gauss y LU no se vieran afectadas por tiempos mucho
mayores que distorsionaran la distancia relativa entre ellas.

Una vez finalizada la etapa de implementación y testeo de los algoritmos, procedimos a realizar una
serie de experimentos que nos permitieran evaluar el comportamiento de los mismos. Además de
analizar como se modifican los resultados a medida que se modifica el parámetro de discretización
h, definimos algoritmos para comparar el desempeño, en términos de la estimación de temperaturas.
Por comodidad, a la hora de diseñar los experimentos, definimos todos los parabrisas con forma cuadrada.

Siguiendo la consigna del TP, planteamos cuatro casos diferentes para analizar como varia la temperatura 
en el punto critico al variar la discretización. Estos casos no fueron
generados al azar, sino que para optimizar el tiempo de cómputo, creamos a mano cada instancia para 
realizar un experimento fijo. Con esto queremos decir que, además de 
analizar la variación de la temperatura en función de la granularidad, planteamos para cada experimento 
una hipótesis aparte, que corroboraremos o 
refutaremos luego de analizar los resultados.


%Finalmente, corrimos los experimentos utilizando MatLab. Elegimos este programa principalmente
%porque permite obtener de una manera simple los gr ́aficos que queriamos mostrar. A su vez, nuestras
%decisiones de implementacion de “main.cpp” y “armaInFile.py” nos permitieron automatizar en gran
%medida el proceso de experimentacion, por lo cual no nos demando excesivo tiempo implementar esta
%etapa del desarrollo (si lo demando el tener que pensar que experimentos realizar y como mostrar
%los resultados). Los experimentos de MatLab tienen como salida los graficos que presentamos en la
%siguiente seccion.
