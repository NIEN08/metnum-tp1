\section{Desarrollo}

\subsection{Sobre la implementaci\'on}
En principio, y con la intencion de entender el problema en profundidad, planteamos un ejemplo que resolvimos manualmente. A partir de este ejemplo
notamos un patron en el comportamiento del sistema. Por lo tanto recrearemos a continuaci\'on dicho ejemplo, para dar una noci\'on clara de nuestra 
evoluci\'on en la comprenci\'on de este problema particular.

Asumamos que recibimos un archivo de entrada con los siguientes parametros:\\
3 3 1 1\\
0.5 2.5 1 500

entonces el problema modelado es de la pinta$^6$:\footnotetext[6]{Aclaramos, para los portadores de una imaginaci\'on poco delirante, 
que la circusferencia negra representa una sanguijuela mutante y el cuadrado celeste, al parabrisas.}

\begin{figure}[H]
    \includegraphics[width=0.3\textwidth]{ejP01}
    \caption{Imagen ilustrativa del parabrisas.}
\end{figure}
Luego lo representaremos como muestra el grafico a continuacion, donde cada intersecion de las lineas representa una variable del modelo, de la cual
debemos averiguar su temperatura.
\begin{figure}[H]
    \includegraphics[width=0.3\textwidth]{ejP02}
    \caption{Representaci\'on visual del modelo discretizado.}
\end{figure}

Notese que, si bien C, D y H pertenecen al radio de una sanguijuela, al formar parte del borde estan acondicionados por el sistema de refrigeracion,
por lo cual su temperatura es $-100$ en lugar de $500$.

Planteando la ecuacion de temperatura para cada variable y despejando, obtenemos el siguiente sistema de ecuaciones $Ax=B$:
\begin{equation}
 a\ =\ -100
\end{equation}
\begin{equation}
 b\ =\ -100
\end{equation}
\begin{equation}
 c\ =\ -100
\end{equation}
\begin{equation}
 d\ =\ -100
\end{equation}
\begin{equation}
 e\ =\ -100
\end{equation}
\begin{equation}
 f - \frac{b}{4} - \frac{e}{4} - \frac{g}{4} - \frac{j}{4}\ =\ 0
\end{equation}
\begin{equation}
 g\ =\ 500
\end{equation}
\begin{equation}
 h\ =\ -100
\end{equation}
\begin{equation}
 i\ =\ -100
\end{equation}
\begin{equation}
 j- \frac{f}{4} - \frac{i}{4} - \frac{k}{4} - \frac{n}{4}\ =\ 0
\end{equation}
\begin{equation}
 k- \frac{g}{4} - \frac{j}{4} - \frac{l}{4} - \frac{o}{4}\ =\ 0
\end{equation}
\begin{equation}
 l\ =\ -100
\end{equation}
\begin{equation}
 m\ =\ -100
\end{equation}
\begin{equation}
 n\ =\ -100
\end{equation}
\begin{equation}
 o\ =\ -100
\end{equation}
\begin{equation}
 p\ =\ -100
\end{equation}
 del cual la matriz asociada $A$ es la siguiente:
%Matriz del sistema
\begin{center}
   \begin{tabular}{| c | c | c | c | c | c | c | c | c |c | c |c | c |c | c | c | c | c | c | c | c |c | c |c | c |c | c |c | c |}
     \hline
       & a  & b & c & d & e & f & g & h & i & j & k & l & m & n & o & p  \\ \hline
   (3) & 1  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
   (4) & 0  & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
   (5) & 0  & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
   (6) & 0  & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
   (7) & 0  & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
   (8) & 0  & $-\frac{1}{4} $ & 0 & 0 & $-\frac{1}{4} $ & 1 & $-\frac{1}{4} $ & 0 & 0 & $-\frac{1}{4} $& 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
   (9) & 0  & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
   (10) & 0  & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
   (11) & 0  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 & 0 & 0 & 0 \\ \hline
   (12) & 0  & 0 & 0 & 0 & 0 & $-\frac{1}{4} $ & 0 & 0 & $-\frac{1}{4} $ & 1 & $-\frac{1}{4} $ & 0 & 0 & $-\frac{1}{4} $ & 0 & 0 \\ \hline
   (13) & 0  & 0 & 0 & 0 & 0 & 0 & $-\frac{1}{4} $ & 0 & 0 & $-\frac{1}{4} $ & 1 & $-\frac{1}{4} $ & 0 & 0 & $-\frac{1}{4} $ & 0 \\ \hline
   (14) & 0  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 & 0 \\ \hline
   (15) & 0  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 & 0 \\ \hline
   (16) & 0  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 & 0 \\ \hline
   (17) & 0  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 & 0 \\ \hline
   (18) & 0  & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 0 & 1 \\ \hline
   \end{tabular}
\end{center}
siendo la ecuacion (3) la resultante de despejar la ecuacion de temperatura para la variable $a$, (4) para la variable $b$ y asi sucesivamente.
Ordenandolo de esta manera, la matriz asociada $A$ es una matriz banda de ancho y altura n, donde n es la cantidad de columnas 
de la matriz de temperaturas. Esto lo deducimos observando la figura 2 y la matriz A,
ya que notamos que para averiguar el valor de la variable $v_{i}$ son necesarios$^7$ los valores de las variables $v_{i-n}$, $v_{i-1}$, 
$v_{i+1}$, $v_{i+n}$, donde n hace referencia a la cantidad de columnas.
\footnotetext[7]{Siempre y cuando $v_{i}$ no pertenesca a un borde o este cubierta por una sanguijuela.}
Notese que en las ecuaciones, o lo que es lo mismo, matriz asociada al sistema no se hicieron remplazos previos. Con esto nos referimos a no reemplazar
 en las ecuaciones de calor automaticamente los valores conocidos, como los del borde o los afectados por sanguijuelas. Un ejemplo de esto se daria 
 al usar las ecuaciones 4, 7 y 9 para reemplazar los valores en la ecuacion 8. Tomamos esta decision porque consideramos que esos reemplazos son parte
 de la resolucion total del sistema, por lo que deberian verse reflejados en la medicion de tiempos. SIn embargo, si hicieramos los reemplazos 
 en la generacion de la matriz asociada al sistema, no podriamos medirlos con confiabilidad pues tendriamos la lectura de datos como outlier.

Dejaremos el ejemplo hasta aqui, pues la resolucion del sistema no aporta informaci\'on util. Sin embargo, una vez que hallamos esta estructura 
procedimos a realizar la carga de datos de modo que la matriz asociada a nuestro sistema fuese una matriz banda-n. Cabe destacar, que mientras dos 
miembros del grupo buscaban comprender en profundidad las propiedad del modelo, los otros dos implementaron la estructura para la matriz banda$^8$,
y los algoritmos de Eliminaci\'on Gaussiana y Factorizaci\'on LU. Ahora explicaremos el desarrollo del c\'odigo.
\footnotetext[8]{Por dato del enunciado, en ese momento sabiamos que debiamos obtener una matriz banda a partir del sistema, si bien no sabiamos como
organizar los datos para obtenerla.}

El lenguaje empleado para la implementaci\'on es C++. Si bien la elecci\'on del lenguaje podria considerarse arbitraria, se debio principalmente a la 
cantidad de herramientas y librerias provistas por este lenguaje. 

En primer instancia, creamos una clase llamada BDouble para representar decimales de
precision doble para guardar el error estimado acumulado. Esto nos sirvio a la hora de debbugear el codigo.
Luego creamos la clase Matrix, que representa a las matrices como un vector de vectores de BDouble. 
Ademas guarda la dimension de la matriz, el ancho y alto de la banda. Para mejorar la complejidad espacial, solo guarda por fila aquellos
coeficientes pertenecientes a la banda, o sea, aquellos que no valen necesariamente cero. Esta clase provee las funciones basicas para matriz, como 
consultar su dimencion o sumar multiplos de filas entre si, pero ademas, contiene las funciones gaussian\_elimination, LU\_factorization, backward\_substitution y 
forward\_substitution. 

Si bien nuestra primera idea fue crear una clase aparte para estos metodos, y por claridad abstraernos en esta de la 
representacion interna de la matriz, al hacerlo nos topamos con un problema en los header's del codigo. Al no poder descubrir el motivo
de dicho problema, recurrimos a la catedra en busca de consejo. Aun asi, no encontramos el motivo. Es por esto que incluimos la implementacion de
estos algoritmos en la clase Matrix. 

Testeamos estos algoritmos con ejemplos peque\~nos escritos a mano, para verificar que se realizaban las cuentas correctamente. Notese que en 
este momento del desarrollo la carga de datos no estaba implementada, por lo que resultaba imposible correr los test provistos por la catedra.

Luego procedimos a crear la interfaz del problema en si, es decir la entrada y salida de datos, la generacion
del sistema, ect. Establecimos como criterio usar el promedio de las temperaturas, de todos los puntos que esten
incluidos en la circunsferencia de radio h con centro en el punto critico,
para la estimacion de la temperatura del mismo. 

Para finalizar la implementacion, codeamos un algoritmo de backtraking simple para calcular cual sanguijuela eliminar,
y un backtraking mejorado con la Formula de Sherman-Morrison. 

Y como se usa??? DAH!


\subsection{Sobre la experimentaci\'on}

Para medir los tiempos de resoluci\'on, utilizamos la funci\'on gettimeof day, que permite medir con
facilidad el lapso de tiempo entre dos momentos de la ejecuci\'on del programa. Decidimos medir
\'unicamente los tiempos que estuvieran estrictamente relacionados a la resoluci\'on del sistema,
dejando afuera, por ejemplo, el tiempo empleado para escribir las soluciones en archivos de salida. La
idea de fondo que nos llev\'o a medir de esta manera fue la de intentar que las magnitudes de los tiempos
empleados por los m\'etodos de triangulaci\'on de Gauss y LU no se vieran afectadas por tiempos mucho
mayores que distorsionaran la distancia relativa entre ellas.

Una vez finalizada la etapa de implementaci\'on y testeo de los algoritmos, procedimos a realizar una
serie de experimentos que nos permitieran evaluar el comportamiento de los mismos. Adem\'as de
analizar c\'omo se modifican los resultados a medida que se modifica el par\'ametro de discretizaci\'on
h, definimos algoritmos para comparar el desempe\~no, en terminos de la estimaci\'on de temperaturas.
Por comodidad, a la hora de dise\~nar los experimentos, definimos todos los parabrisas con forma cuadrada.

Siguiendo la consigna del TP, planteamos cuatro casos diferentes para analizar como varia la temperatura 
en el punto critico al variar la discretizacion. Estos casos no fueron
generados al azar, sino que para optimizar el tiempo de computo, creamos a mano cada instancia para 
realizar por caso un experimento fijo. Con esto queremos decir que, ademas de 
analizar la variaci\'on de la temperatura en funcion de la granularidad, planteamos para cada experimento 
una hipotesis aparte, que corroboraremos o 
refutaremos luego de analizar los resultados.


%Finalmente, corrimos los experimentos utilizando MatLab. Elegimos este programa principalmente
%porque permite obtener de una manera simple los gr ́aficos que queriamos mostrar. A su vez, nuestras
%decisiones de implementacion de “main.cpp” y “armaInFile.py” nos permitieron automatizar en gran
%medida el proceso de experimentacion, por lo cual no nos demando excesivo tiempo implementar esta
%etapa del desarrollo (si lo demando el tener que pensar que experimentos realizar y como mostrar
%los resultados). Los experimentos de MatLab tienen como salida los graficos que presentamos en la
%siguiente seccion.
